// Для последовательности s1,s2,s3,…,sn−1,sn будем называть подотрезком 
// подпоследовательность вида si,si+1,si+2,…,sj−2,sj−1 для некоторых i и j, i≤j,
// т.е. подотрезок — это непрерывная подпоследовательность.

// Напишите функцию max_increasing_len, которая принимает последовательность, хранящуюся 
// в std::list, по двум итераторам, и вычисляет для неё длину самого длинного строго
// возрастающего подотрезка.

//Ограничения: не используйте другие контейнеры, не копируйте элементы из списка.

// так как в задании не указан тип элементов,
// которые хранятся в списке, то давайте сделаем
// эту функцию шаблонной
// Параметр It — это тип итератора 

template<class It>
size_t max_increasing_len(It p, It q)
{
  if(p == q) return 0;

  size_t current = 1, last = 1;
  for(++p; start != q; start++){
    if(*p > *prev(p)){
      current++;
    }
    else {
      last = current > last ? current : last;
      current = 1;
    }
  }
  return current > last ? current : last;
}

int main(){
	std::list<int> const l1 = {7,8,9,4,5,6,1,2,3,4};
	size_t len1 = max_increasing_len(l1.begin(), l1.end()); // 4, соответствует подотрезку 1,2,3,4

	std::list<int> const l2 = {-3,-2,-1,0,0,1,2,3,4,5};
	size_t len2 = max_increasing_len(l2.begin(), l2.end()); // 6, соответствует подотрезку 0,1,2,3,4,5
	return 0;
}
